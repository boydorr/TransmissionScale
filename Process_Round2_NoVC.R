# Version updated November 2020
rm(list=ls()); options(stringsAsFactors = F)

library(lubridate)
library(plyr)
library(ggplot2)
library(reshape2)
#library(kSamples)
#library(SimInfMakeData)
library(fitdistrplus)
#library("plot3D")

source("R/computeCasesPerMonthOutside.R")
source("R/computeShiftHistogramPointsOutside.R")

# Function to plot density histograms
p.dh <- function ( dh, abc, ymax, dog.density.hist.breaks, freq=T ) {
  dh$abc.var <- abc$abc.var; dh$densityDependence <- abc$densityDependence
  dh$ar <- ifelse (dh$Param == "data", "Data", ifelse(abc$abc.var > alfa, "Accepted", "Rejected"))
  colnames(dh)[1:(length(j.dog.density.hist.breaks))] <- j.dog.density.hist.breaks
  shift.bounds$breaks <- j.dog.density.hist.breaks
  #dh <- dh[,2:ncol(dh)] # remove the -5 column that contains "empty" cells
  m.dh <- melt(dh, id.vars = c("Param","ar","abc.var","densityDependence")); m.dh$variable <- as.numeric(as.character(m.dh$variable)) #; m.mh$variable <- ifelse(m.mh$variable == 100000, 405, m.mh$variable)
  if (freq) { # frequencies
    p.dh <- ggplot(subset(m.dh, abc.var > alfa), aes(x=variable, y=value)) + geom_line(aes(group=Param, colour=densityDependence), alpha=0.2) +
      geom_line(data=subset(m.dh, Param=="data"), aes(x=variable, y=value), colour = "red") +
      scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1)) + xlab("Standardised dog density at case location") + ylab("Case frequency") + theme_light(); p.dh
  } else { # densities
    dh.mat <- as.matrix(dh[,1:length(j.dog.density.hist.breaks)])
    dh.mat[,1] <- 0 # all zeros in first column; do this before computing sums
    dh.mat.densities <- (1/density.breaks.by) * dh.mat / rowSums(dh.mat)
    dh.densities <- as.data.frame(dh.mat.densities)
    dh.densities <- cbind(dh.densities, Param=dh$Param, ar=dh$ar, abc.var=dh$abc.var, densityDependence=dh$densityDependence)
    m.dh <- melt(dh.densities, id.vars = c("Param","ar","abc.var","densityDependence")); m.dh$variable <- as.numeric(as.character(m.dh$variable)) #; m.mh$variable <- ifelse(m.mh$variable == 100000, 405, m.mh$variable)
    p.dh <- ggplot(subset(m.dh, abc.var > alfa), aes(x=variable, y=value)) +
      geom_line(aes(group=Param, colour=densityDependence), alpha=0.2) +
      geom_line(data=subset(m.dh, Param=="data"), aes(x=variable, y=value), colour = "red") +
      geom_line(data=shift.bounds, aes(x=breaks, y=ub), colour=sc.colours$bright.blue, lty=1, size=0.5) +
      geom_line(data=shift.bounds, aes(x=breaks, y=lb), colour=sc.colours$bright.blue, lty=1, size=0.5) +
      scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1)) + xlab("Standardised dog density at case location") + ylab("Case density") + 
      theme_light() + theme(legend.position = "bottom"); p.dh
  }
  return(p.dh)
}

# Process_ABC.R
ff <- "/Volumes/LECKIE1/Rabies_Sim_Output/"
#ff <- "/Volumes/large_data/Rabies_Sim_Output/"
ff_criteria <- "/Volumes/LECKIE1/Rabies_Sim_Output/abc_criteria/"
start.date <- as.Date('2002-01-01')
end.date <- as.Date('2015-12-31')
mths <- seq(start.date, end.date, by="month")
qrts <- seq(start.date, end.date, by="quarter")
month.vec.dots <- format(seq(start.date, end.date, by="month"), format = "%Y.%m.%d") #; year.vec <- as.character(seq(start.date, end.date, by="year"))
month.vec <- format(seq(start.date, end.date, by="month"), format = "%Y-%m-%d") #; year.vec <- as.character(seq(start.date, end.date, by="year"))
detection.percentage <- 100
animal.type <- "carnivores"

source("Style_Sheet.R")

# ---- Load up bounds for acceptance/rejection ----
cases.per.month.bounds <- readRDS(paste0(ff_criteria, "c_cases_per_month_bounds.rda"))
cases.per.month.hist.breaks <- readRDS(paste0(ff_criteria, "c_cases_per_month_hist_breaks.rda"))
cases.per.month <- readRDS(paste0(ff_criteria, "c_cases_per_month.rda"))

shift.bounds <- readRDS(paste0(ff_criteria, "shift_bounds.rda"))
dog.densities.hist <- readRDS(paste0(ff_criteria, "dog_densities_hist.rda"))
dog.density.hist.breaks <- readRDS(paste0(ff_criteria, "dog_density_hist_breaks.rda"))
dog.density.hist.mids <- readRDS(paste0(ff_criteria, "dog_density_hist_mids.rda"))
j.dog.density.hist.breaks <- readRDS(paste0(ff_criteria, "j_dog_density_hist_breaks.rda"))
density.breaks.by <- readRDS(paste0(ff_criteria, "density_breaks_by.rda"))

# ---- Post-processing ----
mean.density.period <- 22.43698

# Set stuff up
alfa <- 0.01
model <- "Round2_NoVC"; 
# end.date <- as.Date('2020-12-31')
spatial.scale <- "1000";
paramMinMax <- c(1,7100)
load.only <- T
param.ids.str <- sprintf("%.3d", seq(paramMinMax[1], paramMinMax[2]))
paramMinMax.str <- paste(sprintf("%.3d", paramMinMax),collapse="_")

date.format <- "%Y-%m-%d"

postprocessing.folder <- paste0("postprocessing")
experiment.id <- paste0(model, "_", spatial.scale, "/", postprocessing.folder)

# Read in summary files generated by Java code
abc <- read.csv(paste0(ff, experiment.id, "/abc_", paramMinMax.str, ".csv")) # This is the file produced by the post-processing step in Java
mt <- read.csv(paste0(ff, experiment.id, "/monthlyTally_", paramMinMax.str, ".csv"))
mh <- read.csv(paste0(ff, experiment.id, "/monthlyHistogram_", paramMinMax.str, ".csv"))
dh1000 <- read.csv(paste0(ff, experiment.id, "/densityHistogram1000_", paramMinMax.str, ".csv"))
outputs <- read.csv(paste0(ff, model, "_", spatial.scale, "/", "/output_files/epi_outcomes_", paramMinMax.str,".csv"))
output.cols <- c("nDemographicEvents","nBiteEvents","nTransmissions","nAbandonments","nBitesE","nBitesV","nFailedTransmissions",
                 "nReinfections","nDistinctS","nDistinctE","nDistinctV","nDiedE")
abc <- cbind(abc, rbind(rep(-1, length(output.cols)), outputs[output.cols]))

ddh <- read.csv(paste0(ff, experiment.id, "/distinctDogs_", paramMinMax.str, ".csv"))

head(abc); dim(abc)
summary(abc[2:nrow(abc),])
table(abc$stoppedEarly)


# ------------------------- COMPUTE ABC STATS ----------------------------

if (load.only) {
  load(paste0(paste0(ff, experiment.id, "/abc_stats_", paramMinMax.str, ".rda")))
} else {
  # Compute ABC statistics (Anderson-Darling, not easily available in Java)
  abc$Proportion.noncontributors <- abc$numNonContributors / abc$numDetectableDogs
  abc$Proportion.superspreaders <- abc$numSuperspreaders / abc$numDetectableDogs

  # Cases per month falls inside ... (how many of the points are outside!)
  abc$cases.per.month.outside <- 0
  abc$shift.histogram.points.outside <- 0

  # Convert monthly tally to a version without Param to use in matching
  mt.num <- mt; mt.num$Param <- NULL

  for (rr in 1:nrow(abc)) {
    # Compute test statistics and add to abc data.frame
    if (rr > 1){
      print(rr)
      # Cases per month distribution
      # if (ncol(mh)!=(length(cases.per.month.hist.breaks))) stop("The number of columns in mh is not equal to the number of breaks to be used.")
      abc$cases.per.month.outside[rr] <- computeCasesPerMonthOutside(cases.per.month.bounds, as.numeric(mt.num[rr,]), cases.per.month.hist.breaks, do.plot=F)
      #title(paste0("rr: ", rr, "\nNum outside: ", abc$cases.per.month.outside[rr]))

      # Density - shift - distribution
      if (ncol(dh1000)!=(length(dog.density.hist.breaks))) stop("The number of columns in dh1000 is not equal to the number of breaks to be used.")
      density.counts <- as.numeric(dh1000[rr,1:(length(dog.density.hist.breaks)-1)])
      #density.counts[1:2] <- 0 # This is the number of cases in empty space - we ignore this
      density.relative <- (1/density.breaks.by) * density.counts / sum(density.counts)
      abc$shift.histogram.points.outside[rr] <- computeShiftHistogramPointsOutside(shift.bounds, densities = density.relative, hist.breaks = dog.density.hist.breaks, hist.mids = dog.density.hist.mids, do.plot=F)
      #if (abc$shift.histogram.points.outside[rr] < 4) {
      #  compute.shift.histogram.points.outside(shift.bounds, densities = density.relative, hist.breaks = dog.density.hist.breaks, hist.mids = dog.density.hist.mids, do.plot=T)
      #}
    }
  }
  # Some additional statistics to add in ...
  # Total number of cases and maximum number of cases per month
  for (rr in 1:nrow(mt)) {
    max <- max(mt[rr,1:(ncol(mt)-1)])
    abc$maxPerMonth[rr] <- ifelse((abc$stoppedEarly[rr]=="true" & abc$Param[rr] != "data"), -1, max)
  }
  # # Maximum number of cases per month per cell
  # for (rr in 1:nrow(mc1000)) {
  #   max <- max(mc1000[rr,1:(ncol(mc1000)-1)])
  #   abc$maxPerMonthPer1000[rr] <- ifelse((abc$stoppedEarly[rr]=="true" & abc$Param[rr] != "data"), -1, max)
  # }
  summary(abc$maxPerMonth); summary(abc$maxPerMonthPer1000); summary(abc$totalCases)
  save(abc, file=paste0(paste0(ff, experiment.id, "/abc_stats_", paramMinMax.str, ".rda")))

}

# Plot those that stopped early, and R0 values calculated from them
p.stoppedEarly <- ggplot(subset(abc, R0<=5 & Param!="data"), aes(x=R0)) + geom_histogram(position = "stack", aes(fill=stoppedEarly));p.stoppedEarly
min.stoppedEarly <- min(subset(abc, stoppedEarly=="true" & Param!="data")$R0)
max.not.stoppedEarly <- max(subset(abc, stoppedEarly=="false" & Param!="data")$R0)
ggsave(plot = p.stoppedEarly, title = paste0(experiment.id, "\nMin R0 stopped early = ", min.stoppedEarly,"\nMax R0 completed = ", max.not.stoppedEarly),
       filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_R0_stoppedEarly.pdf"))
# How big can an outbreak get before we stop it early?
summary(subset(abc, stoppedEarly == "false")$numDetectableDogs)


# ---- Accept / Reject ----

table(abc$stoppedEarly)/nrow(abc)
table(cpm=abc$cases.per.month.outside, shift=abc$shift.histogram.points.outside)
# Threshold points ...(baseline 2, 7, baseline for full 50k runs was 2,6)
# Now used 1 and 3 for most recent 50k, given enlarged bounds
thresh.cpm <- 2
thresh.shift <- 4
thresh.nCases <- 10000
table(abc$cases.per.month.outside <= thresh.cpm)
table(abc$shift.histogram.points.outside <= thresh.shift)
table(abc$cases.per.month.outside <= thresh.cpm, abc$shift.histogram.points.outside <= thresh.shift)
table(abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside <= thresh.shift, abc$R0 > 0.95)
table(abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside <= thresh.shift, abc$maxPerMonth<220)
table(abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside <= thresh.shift & abc$R0 > 0.95, abc$maxPerMonth<220)

summary(abc$maxPerMonth)

abc$Accepted <- (abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside <= thresh.shift & abc$stoppingReason == "Completed")
#abc$Accepted <- (abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside<= thresh.shift & abc$R0 > 0.95 & abc$R0 < 1.2)
#abc$Accepted <- (abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside<= thresh.shift & abc$R0 > 0.95 & abc$R0 < 1.5)
# abc$Accepted <- (abc$cases.per.month.outside + abc$shift.histogram.points.outside <= (thresh.shift+thresh.cpm) & abc$R0 > 0.95)
#abc$Accepted <- (abc$cases.per.month.outside <= thresh.cpm & abc$shift.histogram.points.outside<= thresh.shift & abc$R0 > 0.95 & abc$maxPerMonth>=0 & abc$maxPerMonth <= 220)
#abc$Accepted <- (abc$shift.histogram.points.outside <= 1 & abc$R0>0.95 & abc$R0 < 1.5)
#abc$Accepted <- (abc$cases.per.month.outside <= 1 & abc$R0>0.95 & abc$R0 < 1.5)
abc$Accepted <- (abc$numDetectableDogs <= thresh.nCases & abc$stoppingReason == "Completed")

abc$Accepted_Alfa <- ifelse(abc$Accepted, 0.3, 0)
table(abc$Accepted)

#
#abc$Accepted_Alfa <- ifelse(abc$ThMean %in% pr.acc.filtered$ThMean & abc$TdMean %in% pr.acc.filtered$TdMean & abc$ThShape %in% pr.acc.filtered$ThShape & abc$incursionRate %in% pr.acc.filtered$incursionRate, 0.3,0)
table(abc$Accepted_Alfa)

abc.vars.str <- "Accepted_Alfa"
#abc.vars.str <- "all_runs"
#abc.vars.str <- c("Accepted_Alfa","all_runs")

# ------------------------- PLOTTING ----------------------------
alfa <- 0.00
# Make diagnostic plots
for ( abc.var.str in abc.vars.str ) {
  # Setup
  if (abc.var.str %in% c("all_runs","TESTBEST", "TESTBEST2")) {
    abc$abc.var <- 1 # Plot all outputs, not just accepted runs
  } else {
    abc$abc.var <- abc[,abc.var.str]
    abc$abc.var[1] <- 1 # The first row is the data ... so set "distance" (really 1-distance, i.e. probability of matching) to one
  }

  palette.ar2 <- c(Rejected=sc.colours$grey, Accepted=sc.colours$orange)
  palette.ar3 <- c(Data=sc.colours$bright.red, Rejected=sc.colours$grey, Accepted=sc.colours$orange)
  palette.ad2 <- c(Data=sc.colours$bright.red, Accepted=sc.colours$orange)

  # Compute some summary information
  meanR0Accept <- sprintf("%0.2f", mean(subset(abc, (abc.var > alfa & Param!="data"))$R0), na.rm=T)
  nAccept <- nrow(subset(abc, abc.var > alfa & Param!="data"))
  percAccept <- sprintf("%0.2f", 100* nAccept / (nrow(abc)-1))

  # Plot timeseries accepted and rejected
  mt$abc.var <- abc$abc.var; mt$densityDependence <- abc$densityDependence; mt$maxPerMonth <- abc$maxPerMonth; mt$ThShape <- abc$ThShape;mt$TdMean <- abc$TdMean;
  mt$incursionRate <- abc$incursionRate; mt$maxDD <- abc$maxDD
  mt$ar <- ifelse (mt$Param == "data", "Data", ifelse(abc$abc.var > alfa, "Accepted", "Rejected"))
  m.mt <- melt(mt, id.vars = c("Param", "ar","abc.var","densityDependence","maxPerMonth","ThShape","incursionRate","maxDD","TdMean")); m.mt$variable <- as.numeric(gsub("X", replacement = "", m.mt$variable)); m.mt$Month <- start.date + m.mt$variable
  ##p.ts <- ggplot(m.mt, aes(x=Month, y=value)) + geom_line(aes(group=Param, alpha=abc.var, colour=factor(abc.var>alfa))) + ylim(c(0,250)); p.ts
  ##p.ts <- ggplot(subset(m.mt, abc.var>alfa), aes(x=Month, y=value)) + geom_line(aes(group=Param, alpha=abc.var, colour=ar)) +
    ##ylim(c(0,250)) + scale_colour_manual(values = palette.ad2); p.ts
  p.ts <- ggplot(subset(m.mt, abc.var>alfa), aes(x=Month, y=value)) + geom_line(aes(group=Param, colour=densityDependence),alpha=0.3, size=0.3) +
    geom_line(data=subset(m.mt, Param=="data"), aes(x=Month, y=value), colour = "red") +
    scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1))
  p.ts <- p.ts + ylim(c(0,maxy)) +
    theme_light() + theme(legend.position = "bottom");p.ts
  ggsave(plot = p.ts, title = paste0(experiment.id, " ", abc.var.str), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_ts.pdf"),
         width = 21, height = 15, units="cm")

  # Plot timeseries by ThShape
  p.ts <- ggplot(subset(m.mt, abc.var>alfa), aes(x=Month, y=value)) + geom_line(aes(group=Param, colour=log1p(ThShape),alpha=ThShape),  size=0.2) +
    geom_line(data=subset(m.mt, Param=="data"), aes(x=Month, y=value), colour = "red") +
    scale_colour_gradient(low = sc.colours$bright.red, high = sc.colours$blue)
  p.ts <- p.ts + ylim(c(0,maxy));
  p.ts + theme_classic()
  ggsave(plot = p.ts, title = paste0(experiment.id, " ", abc.var.str), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_ts_Thshape.pdf"))

  p.ts <- ggplot(subset(m.mt, abc.var>alfa), aes(x=Month, y=value)) + geom_line(aes(group=Param, colour=log1p(TdMean),alpha=TdMean),  size=0.2) +
    geom_line(data=subset(m.mt, Param=="data"), aes(x=Month, y=value), colour = "red") +
    scale_colour_gradient(low = sc.colours$bright.red, high = sc.colours$blue)
  p.ts <- p.ts + ylim(c(0,maxy));
  p.ts + theme_classic()
  ggsave(plot = p.ts, title = paste0(experiment.id, " ", abc.var.str), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_ts_TdMean.pdf"))

    #p.ts <- ggplot(subset(m.mt, abc.var>alfa & ar!="Data"), aes(x=Month, y=value)) + geom_line(aes(group=Param, colour=incursionRate, alpha=abc.var)) +
  #  geom_line(data=subset(m.mt, Param=="data"), aes(x=Month, y=value), colour = "red") +
  #  scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange); p.ts + theme_classic()

  # # Plot cases per month histogram by accepted and rejected
  mh$abc.var <- abc$abc.var;
  mh$densityDependence <- abc$densityDependence
  mh$ar <- ifelse (mh$Param == "data", "Data", ifelse(abc$abc.var > alfa, "Accepted", "Rejected"))
  m.mh <- melt(mh, id.vars = c("Param","ar","abc.var","densityDependence")); m.mh$variable <- as.numeric(gsub("X", replacement = "", m.mh$variable)); m.mh$variable <- ifelse(m.mh$variable == 100000, 405, m.mh$variable)
  cpmb <- cbind(cases.per.month.bounds, breaks=cases.per.month.hist.breaks[2:length(cases.per.month.hist.breaks)])
  p.mh <- ggplot(subset(m.mh, abc.var > alfa), aes(x=variable, y=value)) + geom_line(aes(group=Param, colour=densityDependence), alpha = 0.2) +
    geom_line(data=subset(m.mh, Param=="data"), aes(x=variable, y=value), colour = "red") +
    geom_line(data=subset(cpmb,breaks<5000), aes(x=breaks, y=lb), colour=sc.colours$bright.blue, lty=1, size=0.5) +
    geom_line(data=subset(cpmb,breaks<5000), aes(x=breaks, y=ub), colour=sc.colours$bright.blue, lty=1, size=0.5) +
    ylim(c(0,100)) + scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1)) + 
    theme_light() +
    theme(legend.position = "bottom"); p.mh 
  ggsave(plot = p.mh, title = paste0("Distribution of number of cases per month\n", experiment.id, " ", abc.var.str), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_mh.pdf"),
         width = 21, height = 15, units = "cm") 


  # Plot functional response curves by accepted/rejected
  #p.holling <- plotHolling (abc = subset(abc, Param!="data" & abc.var > alfa), alfa = alfa, palet = palette.ar2, NMax = 60, accepted.only = T, ymax = 2.0); p.holling
  #ggsave(plot = p.holling, title = paste0("Holling type II functional response\n", experiment.id, " ", abc.var.str, "\nAccepted ", nAccept, " runs or ", percAccept, "%", " and mean accepted R0 = ", meanR0Accept), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_holling.pdf"))


  # Plot the parameters in a way that gives all parameters a colour/size/axis code
  acc <- subset(abc, Accepted & stoppedEarly=="false" & Param!="data")
  # scatter3D(z=acc$ThMean, y=acc$TdMean, colvar=acc$incursionRate, x = acc$ThShape,
  #           bty = "g", addlines = TRUE, length = 0.5, width = 0.5, pch=20, col = ramp.col (col = c("orange", "darkred"), n = 100, alpha = 1), type="h",
  #           xlab="ThShape", ylab="TdMean", zlab= "ThMean",
  #           ticktype="detailed")

  #qplot(acc$ThMean, acc$TdMean, colour=acc$ThShape, alpha=acc$incursionRate) + scale_colour_gradient(low="blue", high="green")
  #qplot(acc$ThMean, acc$TdMean, alpha=acc$incursionRate)
  p.thtd.plus <- ggplot(data=acc, aes(x=ThMean, y=TdMean)) + 
    geom_point(aes(alpha=ThShape, colour=densityDependence, size=R0, shape=maxDD>100)) +
    scale_colour_gradient(low=sc.colours$bright.blue, high=sc.colours$orange, limits = c(0,1)) + xlim(c(0,5)) + ylim(c(0,25)) + theme_light(); p.thtd.plus
  ggsave(plot = p.thtd.plus, title = paste0("ABC outcomes\n", experiment.id, " ", abc.var.str,"\nMean accepted R0 = ", meanR0Accept), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_ThTd_nonfacetted.pdf"))

  # Numbers of points outside distributions, faceted.
  p.facet <- ggplot(data=acc, aes(x=ThMean, y=TdMean)) + geom_point(aes(alpha=ThShape, colour=densityDependence, size=incursionRate, shape=maxDD>100)) +
    scale_colour_gradient(low=sc.colours$bright.blue, high=sc.colours$orange) + facet_grid(cases.per.month.outside ~ shift.histogram.points.outside) + xlim(c(0,5)) + ylim(c(0,25)) + theme_light()
  ggsave(plot = p.facet, title = paste0("ABC outcomes\n", experiment.id, " ", abc.var.str,"\nMean accepted R0 = ", meanR0Accept), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_ThTd_facetted.pdf"))

  #qplot(acc$incursionRate, acc$TdMean) # Probably positive correlation, so as discovery takes longer, incR increases
  #qplot(acc$incursionRate, acc$ThMean) # Probably positive correlation, so as handling takes longer, incR increases
  #qplot(acc$incursionRate, acc$ThShape, size=acc$maxDD>100, colour=acc$densityDependence) + scale_colour_gradient(low="blue", high="green") # no correlation

  #qplot(acc$ThScale, acc$ThShape, colour=acc$TdMean, size=acc$maxDD) # Clearly a tradeoff between shape and scale
  #qplot(acc$ThMean, acc$ThShape, colour=acc$densityDependence, size=acc$maxDD, alpha=acc$sdDD) + scale_colour_gradient(low="blue", high="green")
  #qplot(acc$sdDD, acc$maxDD) # sd and maxDD are highly correlated

  #qplot(acc$ThMean, acc$TdMean, colour=acc$ThShape)
  #qplot(acc$TdMean, acc$ThShape, size=acc$densityDependence) # it is possible to have high TdMean, associated with strong density-dependence, only if v skewed

  #qplot(acc$TdMean, acc$ThShape, alpha=acc$Proportion.superspreaders) # it is possible to have high TdMean, associated with strong density-dependence, only if v skewed

  p.shift.outside <- ggplot(abc, aes(x=shift.histogram.points.outside, group=shift.histogram.points.outside, y=densityDependence)) + geom_boxplot()
  ggsave(plot = p.shift.outside, title = paste0("Shift outside\n", experiment.id, " ", abc.var.str), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_shift_outside.pdf"))

  p.cpm.outside <- ggplot(abc, aes(x=cases.per.month.outside, group=cases.per.month.outside, y=densityDependence)) + geom_boxplot()
  ggsave(plot = p.cpm.outside, title = paste0("Cases per month outside\n", experiment.id, " ", abc.var.str,"\nMean accepted R0 = ", meanR0Accept), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_cpm_outside.pdf"))



  # Plot distinct dogs histogram
  # ---- Superspreaders are dogs that bite more than the 99% quantile of Poisson distribution with the same mean (Jamie Lloyd-Smith) ----
  # my.lambda <- 5
  # test <- data.frame(value = rpois(n = 10000, lambda = my.lambda))
  # test <- data.frame(value = rlnorm(n = 10000, meanlog = 5, sdlog = 2))
  # mu.hat <- mean(test$value)
  # thresh <- qpois(p = 0.99, lambda = mu.hat, lower.tail = T, log.p = F)
  # test$Superspreader <- ifelse(test$value > thresh, T, F)
  # #ggplot(test, aes(x = value)) + geom_histogram(binwidth = 1, aes(fill = Superspreader)) + geom_vline(xintercept = mu.hat)
  # ggplot(test, aes(x = value)) + geom_histogram(bins = 500, aes(fill = Superspreader)) + geom_vline(xintercept = mu.hat)
  # prop.superspreader <- nrow(subset(test, Superspreader))/nrow(test)

  abc$Acc <- factor(abc$abc.var > alfa, levels=c("FALSE","TRUE"))

  # Histogram of the by-run proportion of superspreaders
  data.prop.superspreader <- abc$numSuperspreaders[1] / abc$numDetectableDogs[1]
  ### p.dd.prop <- ggplot(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false")), aes(x = Prop.superspreader)) + geom_histogram(bins=20, aes(fill = abc.var > alfa)) + geom_vline(xintercept = data.prop.superspreader)
  p.dd.prop <- ggplot(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false")), aes(x = Proportion.superspreaders)) + geom_histogram(breaks=seq(0,0.15, by=0.005), aes(fill = Acc)) + geom_vline(xintercept = data.prop.superspreader)
  ggsave(plot = p.dd.prop, title = paste0("Proportion of \n", experiment.id, " ", abc.var.str,"\nProportion superspreaders (data) = ", data.prop.superspreader), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_proportion_superspreaders.pdf"))
  #p.dd.prop <- ggplot(subset(abc, (Param!="data" & NumCases > 0 & stoppedEarly =="false")), aes(x = Prop.superspreader, y = densityDependence)) + geom_point(aes(colour = abc.var > alfa), alpha = 0.8)
  #ggplot(subset(abc, (Param!="data" & NumCases > 0 & stoppedEarly =="false")), aes(y = Superspreader, x = ThMean)) + geom_point(aes(colour = abc.var > alfa), alpha = 0.8)
  # Accepted versus rejected parameter sets, by the proportion of superspreaders
  overallMaxDD <- max(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false"))$maxDD)
  p.dd.thtd.prop <- ggplot(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false")), aes(x = ThMean, y = TdMean)) + geom_point(aes(colour = Acc, size = densityDependence, alpha=Proportion.superspreaders)) +
                    annotate(geom = "text",
                             x = subset(abc, (Param!="data" & abc.var>alfa))$ThMean,
                             y = subset(abc, (Param!="data" & abc.var>alfa))$TdMean,
                             label = paste0("maxDD=", subset(abc, (Param!="data" & abc.var>alfa))$maxDD,
                                            ", incRate=", sprintf("%1.2f", subset(abc, (Param!="data" & abc.var>alfa))$incursionRate)), size=3)
  ggsave(plot = p.dd.thtd.prop, title = paste0("Proportion of \n", experiment.id, " ", abc.var.str,"\nProportion superspreaders (data) = ", data.prop.superspreader), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_thtd_proportion_superspreaders.pdf"))

  # Histogram of the by-run proportion of non-contributors
  data.prop.non.contributors <- abc$numNonContributors[1] / abc$numDetectableDogs[1]
  ###p.dd.nc <- ggplot(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false")), aes(x = Proportion.noncontributors)) + geom_histogram(bins=20, aes(fill = abc.var > alfa)) + geom_vline(xintercept = data.prop.non.contributors)
  p.dd.nc <- ggplot(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false")), aes(x = Proportion.noncontributors)) + geom_histogram(breaks=seq(0,1, by=0.025), aes(fill = Acc)) + geom_vline(xintercept = data.prop.non.contributors)
  ggsave(plot = p.dd.nc, title = paste0("Proportion of \n", experiment.id, " ", abc.var.str,"\nProportion non-contributors (data) = ", data.prop.non.contributors), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_proportion_noncontributors.pdf"))

  # Histogram of the max number of distinct dogs bitten
  data.max.dogs.bitten <- abc$maxDD[1]
  p.dd.mdd <- ggplot(subset(abc, (Param!="data" & numDetectableDogs > 0 & stoppedEarly =="false")), aes(x = maxDD)) + 
    geom_freqpoly(aes(colour = abc.var > alfa)) + 
    geom_vline(xintercept = data.max.dogs.bitten) + geom_vline(xintercept = 2*data.max.dogs.bitten, linetype = 2) + 
    scale_x_continuous(limits=c(0,1000)) + scale_y_log10()
  ggsave(plot = p.dd.mdd, title = paste0(experiment.id, " ", abc.var.str,"\nMax dogs bitten (data) = ", data.max.dogs.bitten), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_abc_max_dogs_bitten.pdf"))

  # ----

  ddh$abc.var <- abc$abc.var; ddh$densityDependence <- abc$densityDependence
  ddh$ar <- ifelse (ddh$Param == "data", "Data", ifelse(abc$abc.var > alfa, "Accepted", "Rejected"))
  ddhp <- ddh
  ddhp[,1:83] <- ddhp[,1:83] / rowSums(ddhp[,1:83])
  ###ddh$rowSums <- rowSums(ddh[,1:21]); ddh[,1:21] <- ddh[,1:21] / ddh$rowSums
  m.ddh <- melt(ddhp, id.vars = c("Param","ar","abc.var","densityDependence")); m.ddh$variable <- as.numeric(gsub("X", replacement = "", m.ddh$variable)); m.ddh$variable <- ifelse(m.ddh$variable == 10000, 110, m.ddh$variable)
  p.ddh <- ggplot(subset(m.ddh, abc.var > alfa), aes(x=variable, y=value)) + 
    geom_line(aes(group=Param, colour=densityDependence), alpha = 0.2) +
    geom_line(data=subset(m.ddh, Param=="data"), aes(x=variable, y=value), colour = "red") +
    scale_x_continuous(name="Number of distinct dogs bitten") + scale_y_continuous(name = "Relative frequency", limits = c(0,1)) +
    scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1)) +
    theme_light(); p.ddh
  ggsave(plot = p.ddh, title = paste0("Numbers of distinct dogs bitten\n", experiment.id, " ", abc.var.str,"\nMean accepted R0 = ", meanR0Accept), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_distinctDogs.pdf"))

  ddhp$ThShape <- abc$ThShape; ddhp$ThMean <- abc$ThMean; ddhp$TdMean <- abc$TdMean; ddhp$incursionRate <- abc$incursionRate
  m.ddh <- melt(ddhp, id.vars = c("Param","ar","abc.var","densityDependence","ThShape","ThMean","TdMean","incursionRate")); m.ddh$variable <- as.numeric(gsub("X", replacement = "", m.ddh$variable)); m.ddh$variable <- ifelse(m.ddh$variable == 10000, 110, m.ddh$variable)
  p.ddh <- ggplot(subset(m.ddh, abc.var > alfa & Param!="data"), aes(x=variable, y=value)) + geom_line(aes(group=Param, alpha=abc.var, colour=ThShape)) +
    geom_line(data=subset(m.ddh, Param=="data"), aes(x=variable, y=value), colour = "red") +
    scale_x_sqrt(name="Number of distinct dogs bitten") + scale_y_continuous(name = "Relative frequency", limits = c(0,1)) +
    scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange); p.ddh + theme_classic()

  # Plot density histograms
  #p.dh250 <- p.dh(dh = dh250, abc = abc, ymax = 2000); p.dh250
  #ggsave(plot = p.dh250, title = paste0("Relative density\n", experiment.id, " ", abc.var.str,"\nMean accepted R0 = ", meanR0Accept), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_relative_density250.pdf"))
  p.dh1000 <- p.dh(dh = dh1000, abc = abc, ymax = 700, freq = F); p.dh1000
  ggsave(plot = p.dh1000, 
         title = paste0("Relative density\n", experiment.id, " ", abc.var.str,"\nMean accepted R0 = ", meanR0Accept), 
         filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_",abc.var.str,"_relative_density1000_caseDensity.pdf"), 
         width = 21, height = 15, units = "cm") 
}

table(abc$Accepted)
summary(subset(abc, Accepted == T)$numDetectableDogs) # Accepted runs
summary(subset(abc, Accepted == T)$R0) # Accepted runs
summary(subset(abc, Accepted == T)$maxDD) # Accepted runs - max distinct dogs
summary(subset(abc, Accepted == T)$maxDD > 100) # small number > 100
summary(subset(abc, Accepted == T)$meanDD) # Mean dogs bitten


# Compute proportion accepted of re-simulated runs
names(abc)
pr.acc <- ddply(abc, .(TdMean, ThMean, ThShape, ThScale, densityDependence), summarise,
                param0 = Param[1],
                propAcc = sum(Accepted)/length(Accepted),
                medMaxDD = median(maxDD),
                maxMaxDD = max(maxDD),
                medR0 = median(R0),
                maxR0 = max(R0),
                medMaxPerMonth = median(maxPerMonth),
                maxMaxPerMonth = max(maxPerMonth))
summary(pr.acc)
# Plot proportion accepted at each spatial scale, by ThMean, TdMean parameters
p = ggplot(pr.acc, aes(x=ThMean, y=TdMean)) + geom_point(aes(alpha=propAcc)); p
ggsave(plot = p, width = 21, height = 17, units = "cm", path = ff_figs, filename = "all_accepted_ThTd.pdf")
# As above, but highlighting those with proportion accepted above a threshold
p = ggplot(pr.acc, aes(x=ThMean, y=TdMean)) + geom_point(aes(alpha=propAcc, colour=propAcc > 0.30, shape=medMaxDD>100)) + 
  theme_light() ; p
ggsave(plot = p, width = 21, height = 10, units = "cm", path = ff_figs, filename = "Round2_Scatter_ThTd_propAcc_threshold.pdf")



# --------------------------------- Compute intersection between w and wo vaccination ------------------------------------

NoVC_Accepted <- subset(pr.acc, propAcc > 0.4)
dim(NoVC_Accepted)

NoVC_Accepted <- pr.acc
load("/Volumes/LECKIE1/Rabies_Sim_Output/Round2_1000/postprocessing/abc_stats_001_7100.rda")


# Accept or reject runs
thresh.cpm <- 2
thresh.shift <- 4
all.accepted <- abc
all.accepted$Accepted <- (all.accepted$cases.per.month.outside <= thresh.cpm & all.accepted$shift.histogram.points.outside <= thresh.shift & all.accepted$stoppingReason == "Completed")
#all.accepted$Accepted <- (all.accepted$cases.per.month.outside <= thresh.cpm & all.accepted$shift.histogram.points.outside <= thresh.shift & all.accepted$stoppingReason == "Completed")
table(all.accepted$Accepted); 

all.accepted <- subset(all.accepted, Param!="data") # exclude the data
dim(all.accepted)

# Compute proportion accepted of re-simulated runs
pr.acc <- ddply(all.accepted, .(TdMean, ThMean, ThShape, ThScale, densityDependence, Res, Res.label), summarise,
                propAcc = sum(Accepted)/length(Accepted),
                medMaxDD = median(maxDD),
                maxMaxDD = max(maxDD),
                medR0 = median(R0),
                maxR0 = max(R0),
                medMaxPerMonth = median(maxPerMonth),
                maxMaxPerMonth = max(maxPerMonth))
#pr.acc.filtered <- subset(pr.acc, propAcc>=0.35)
library(dplyr)
pr.acc.test <- all.accepted %>% group_by(TdMean, ThMean, ThShape, ThScale, densityDependence, Res, Res.label) %>%
  summarise(propAcc = sum(Accepted)/length(Accepted),
            medMaxDD = median(maxDD),
            maxMaxDD = max(maxDD),
            medR0 = median(R0),
            maxR0 = max(R0),
            medMaxPerMonth = median(maxPerMonth),
            maxMaxPerMonth = max(maxPerMonth))
dim(pr.acc)
VC_Accepted <- pr.acc

names(VC_Accepted); names(NoVC_Accepted)

test <- left_join(x = VC_Accepted, y = NoVC_Accepted, 
                  by = c("ThShape" = "ThShape", "ThMean" = "ThMean", "ThShape" = "ThShape", "ThScale" = "ThScale", "densityDependence" = "densityDependence"))
dim(test)
head(test)
summary(test)
dim(VC_Accepted)
dim(NoVC_Accepted)

filter(test, propAcc.x > .2 & propAcc.y > 0.4)
# --------------------------------- Make priors for Round 2 ------------------------------------
if(model=="Round1") {
  # # Make best-fit parameters for second stage
  acc <- subset(abc, Accepted & Param!="data")
  dim(acc)
  acc$Td <- acc$TdMean
  my.priors <- acc[c("ThShape","ThScale","Td","incursionRate")]
  my.priors
  n <- 100
  repeated.priors <- do.call("rbind", replicate(n, my.priors, simplify = FALSE))
  dim(repeated.priors)
  write.table(repeated.priors[c("ThShape","ThScale","Td")], 
              file = paste0(ff, experiment.id, "/Round2_Priors_", spatial.scale, ".csv"), append = FALSE, quote = FALSE, sep = ",", eol = "\n", na = "NA", dec = ".", row.names = FALSE, col.names = TRUE, fileEncoding = "")
}

