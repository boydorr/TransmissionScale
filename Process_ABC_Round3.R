# Last edited by Rebecca Mancy in June 2021
# This file computes ABC acceptance and postprocessing figures from Round3
# rather than figures required for the manuscript per se

rm(list=ls()); options(stringsAsFactors = F)

library(lubridate)
library(plyr)
library(ggplot2)
library(reshape2)
library(fitdistrplus)
library(EnvStats)

source("R/computeCasesPerMonthOutside.R")
source("R/computeShiftHistogramPointsOutside.R")

# Function to plot density histograms
p.dh <- function ( dh, abc, ymax, dog.density.hist.breaks, freq=T ) {
  dh$abc.var <- abc$abc.var; dh$densityDependence <- abc$densityDependence
  dh$ar <- ifelse (dh$Param == "data", "Data", ifelse(abc$abc.var > alfa, "Accepted", "Rejected"))
  colnames(dh)[1:(length(j.dog.density.hist.breaks))] <- j.dog.density.hist.breaks
  shift.bounds$breaks <- j.dog.density.hist.breaks
  #dh <- dh[,2:ncol(dh)] # remove the -5 column that contains "empty" cells
  m.dh <- melt(dh, id.vars = c("Param","ar","abc.var","densityDependence")); m.dh$variable <- as.numeric(as.character(m.dh$variable)) #; m.mh$variable <- ifelse(m.mh$variable == 100000, 405, m.mh$variable)
  if (freq) { # frequencies
    p.dh <- ggplot(subset(m.dh, abc.var > alfa), aes(x=variable, y=value)) + geom_line(aes(group=Param, colour=densityDependence), alpha=0.2) +
      geom_line(data=subset(m.dh, Param=="data"), aes(x=variable, y=value), colour = "red") +
      scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1)) + xlab("Standardised dog density at case location") + ylab("Case frequency") + theme_light(); p.dh
  } else { # densities
    dh.mat <- as.matrix(dh[,1:length(j.dog.density.hist.breaks)])
    dh.mat[,1] <- 0 # all zeros in first column; do this before computing sums
    dh.mat.densities <- (1/density.breaks.by) * dh.mat / rowSums(dh.mat)
    dh.densities <- as.data.frame(dh.mat.densities)
    dh.densities <- cbind(dh.densities, Param=dh$Param, ar=dh$ar, abc.var=dh$abc.var, densityDependence=dh$densityDependence)
    m.dh <- melt(dh.densities, id.vars = c("Param","ar","abc.var","densityDependence")); m.dh$variable <- as.numeric(as.character(m.dh$variable)) #; m.mh$variable <- ifelse(m.mh$variable == 100000, 405, m.mh$variable)
    p.dh <- ggplot(subset(m.dh, abc.var > alfa), aes(x=variable, y=value)) +
      geom_line(aes(group=Param, colour=densityDependence), alpha=0.2) +
      geom_line(data=subset(m.dh, Param=="data"), aes(x=variable, y=value), colour = "red") +
      geom_line(data=shift.bounds, aes(x=breaks, y=ub), colour=sc.colours$bright.blue, lty=1, size=0.5) +
      geom_line(data=shift.bounds, aes(x=breaks, y=lb), colour=sc.colours$bright.blue, lty=1, size=0.5) +
      scale_colour_gradient(low = sc.colours$dark.navy, high = sc.colours$orange, limits = c(0,1)) + xlab("Standardised dog density at case location") + ylab("Case density") + 
      theme_light() + theme(legend.position = "bottom"); p.dh
  }
  return(p.dh)
}

# Process_ABC.R
ff_criteria <- "/Volumes/SimOutput01/Rabies_Sim_Output/abc_criteria/"
ff <- "/Volumes/SimOutput01/Rabies_Sim_Output/"
start.date <- as.Date('2002-01-01')
end.date <- as.Date('2015-12-31')
mths <- seq(start.date, end.date, by="month")
qrts <- seq(start.date, end.date, by="quarter")
month.vec.dots <- format(seq(start.date, end.date, by="month"), format = "%Y.%m.%d") #; year.vec <- as.character(seq(start.date, end.date, by="year"))
month.vec <- format(seq(start.date, end.date, by="month"), format = "%Y-%m-%d") #; year.vec <- as.character(seq(start.date, end.date, by="year"))
detection.percentage <- 100
animal.type <- "carnivores"

source("Style_Sheet.R")

# ---- Load up bounds for acceptance/rejection ----
cases.per.month.bounds <- readRDS(paste0(ff_criteria, "c_cases_per_month_bounds.rda"))
cases.per.month.hist.breaks <- readRDS(paste0(ff_criteria, "c_cases_per_month_hist_breaks.rda"))
cases.per.month <- readRDS(paste0(ff_criteria, "c_cases_per_month.rda"))
shift.bounds <- readRDS(paste0(ff_criteria, "shift_bounds.rda"))
dog.densities.hist <- readRDS(paste0(ff_criteria, "dog_densities_hist.rda"))
dog.density.hist.breaks <- readRDS(paste0(ff_criteria, "dog_density_hist_breaks.rda"))
dog.density.hist.mids <- readRDS(paste0(ff_criteria, "dog_density_hist_mids.rda"))
j.dog.density.hist.breaks <- readRDS(paste0(ff_criteria, "j_dog_density_hist_breaks.rda"))
density.breaks.by <- readRDS(paste0(ff_criteria, "density_breaks_by.rda"))

# ---- Post-processing ----
mean.density.period <- 22.43698

# Set parameters for this round
alfa <- 0.01
model <- "Round3_NAIVE_POP"; 
spatial.scale <- "1000";
paramMinMax <- c(1,1000)
load.only <- F
param.ids.str <- sprintf("%.3d", seq(paramMinMax[1], paramMinMax[2]))
paramMinMax.str <- paste(sprintf("%.3d", paramMinMax),collapse="_")
date.format <- "%Y-%m-%d"
postprocessing.folder <- paste0("postprocessing")
experiment.id <- paste0(model, "_", spatial.scale, "/", postprocessing.folder)

# Read in summary files generated by Java code
abc <- read.csv(paste0(ff, experiment.id, "/abc_", paramMinMax.str, ".csv")) # This is the file produced by the post-processing step in Java
mt <- read.csv(paste0(ff, experiment.id, "/monthlyTally_", paramMinMax.str, ".csv"))
mh <- read.csv(paste0(ff, experiment.id, "/monthlyHistogram_", paramMinMax.str, ".csv"))
dh1000 <- read.csv(paste0(ff, experiment.id, "/densityHistogram1000_", paramMinMax.str, ".csv"))
outputs <- read.csv(paste0(ff, model, "_", spatial.scale, "/", "/output_files/epi_outcomes_", paramMinMax.str,".csv"))
output.cols <- c("nDemographicEvents","nBiteEvents","nTransmissions","nAbandonments","nBitesE","nBitesV","nFailedTransmissions",
                 "nReinfections","nDistinctS","nDistinctE","nDistinctV","nDiedE")
abc <- cbind(abc, rbind(rep(-1, length(output.cols)), outputs[output.cols]))
ddh <- read.csv(paste0(ff, experiment.id, "/distinctDogs_", paramMinMax.str, ".csv"))

head(abc); dim(abc)
summary(abc[2:nrow(abc),])
table(abc$stoppedEarly)

# Plot timeseries
mt$abc.var <- abc$abc.var; mt$densityDependence <- abc$densityDependence; mt$maxPerMonth <- abc$maxPerMonth; mt$ThShape <- abc$ThShape;mt$TdMean <- abc$TdMean;
mt$incursionRate <- abc$incursionRate; mt$maxDD <- abc$maxDD
mt$ar <- ifelse (mt$Param == "data", "Data", ifelse(abc$abc.var > alfa, "Accepted", "Rejected"))
m.mt <- melt(mt, id.vars = c("Param", "ar","densityDependence","ThShape","incursionRate","maxDD","TdMean")); m.mt$variable <- as.numeric(gsub("X", replacement = "", m.mt$variable)); m.mt$Month <- start.date + m.mt$variable
p.ts <- ggplot(m.mt, aes(x=Month, y=value)) + 
  geom_line(data = subset(m.mt, Param!="data"), aes(group=Param, colour=densityDependence),alpha=0.3, size=0.3) +
  geom_line(data=subset(m.mt, Param=="data"), aes(x=Month, y=value), colour = "red") 
p.ts <- p.ts + #+ ylim(c(0,maxy)) +
  theme_light() + theme(legend.position = "bottom");p.ts
ggsave(plot = p.ts, title = paste0(experiment.id), filename = paste0(ff, experiment.id,"/figs/", model, "_", spatial.scale, "_ts.pdf"),
       width = 21, height = 15, units="cm")

summary(abc$R0)
names(abc)
summary(abc$numDetectableDogs) # Summary of overall number of cases

# # Computations of R0, Re, by run from postprocessor, but averaged incorrectly ...
# summary(abc$nTransmissions / abc$numDetectableDogs) # Re: 1.04
# summary((abc$nDistinctE + abc$nDistinctS + abc$nDistinctV)/abc$numDetectableDogs) # Num dogs bitten: 2.290
# summary((abc$nDistinctE) / abc$numDetectableDogs) # bites of E 0.2738
# summary(abc)

# # Cross-check using direct output from simulator
# sim_Round3 <- read.csv(paste0(ff, "Round3_OptNoVC_1000", "/output_files/epi_outcomes_", paramMinMax.str, ".csv")) # This is the file produced by the post-processing step in Java
# dim(sim_Round3)
# abc <- subset(abc, Param != "data")
# dim(abc)
# names(sim_Round3)
# 
# # Td value for run used for R0 calcs
# Td <- 0.262971885968
# # my.rows <- round(abc$TdMean, digits = 5) == 0.26297
# # #abc <- subset(abc, round(TdMean, digits = 5) ==  0.26297)
# # sim_Round3 <- sim_Round3[my.rows,]
# # dim(abc)
# # dim(sim_Round3)
# # 
# # # R0
# # summary(sim_Round3$nTransmissions / abc$numDetectableDogs) # 1.049
# # summary((sim_Round3$nDistinctS + sim_Round3$nDistinctE + sim_Round3$nDistinctV)/abc$numDetectableDogs) # 2.312
# # 
# # 
# # numer <- rexp(100)
# # denom <- rexp(100,0.5)
# # numer/denom
# # (my.ratio <- sum(numer)/sum(denom))
# # (my.means <- mean(numer/denom))

# ------------------------------CHECK IF REQUIRED ??----------------------------------

# # Compute Re and distinct dogs properly by reading in the full runs
# # This uses the four "best" parameter sets without VC, but filters out so we only retain those that correspond
# #      to the runs used in the R0 calculations
# 
# # Load up the file produced by the post-processing step in Java
# sim_round <- "Round2_NoVC_1000"
# paramMinMax.str <- "001_7100" # Number of runs
# sim_Round2_noVC <- read.csv(paste0(ff, sim_round, "/output_files/epi_outcomes_", paramMinMax.str, ".csv"))
# dim(sim_Round2_noVC)
# # Load up abc file produced by R
# abc <- read.csv(paste0(ff, sim_round, "/postprocessing/abc_", paramMinMax.str, ".csv")) # This is the file produced by the post-processing step in Java
# dim(abc)
# 
# my.output <- data.frame(trans.ave = c(), trans.geo = c(), 
#                         dd.ave = c(), dd.geo = c(),
#                         be.ave = c(), be.geo = c()) # Note that we don't currently output distinct S, E, in full run output
# for (rr in 1:nrow(abc)) {
#   if (round(abc$TdMean[rr], digits = 5) == 0.26297) {
#     print(rr)
#     # Compute statistics
#     sim_1 <- read.csv(paste0(ff, sim_round, "/output_files/",sim_round, "_sim_cases_",sprintf("%.3d", c(rr)),".csv" ))
#     mean_transmissions <- mean(sim_1$nTransmissions)
#     mean_DD <- mean(sim_1$nDistinctDogs)
#     geo_transmissions <- geoMean(sim_1$nTransmissions + 1) - 1
#     geo_dd <- geoMean(sim_1$nDistinctDogs + 1) - 1
#     mean_be <- mean(sim_1$nBitesE)
#     geo_be <- geoMean(sim_1$nBitesE + 1) - 1
#     my.output <- rbind(my.output, data.frame(trans.ave = mean_transmissions, trans.geo = geo_transmissions, 
#                                              dd.ave = mean_DD, dd.geo = geo_dd,
#                                              be.ave = mean_be, be.geo = geo_be))
#   }
# }
# dim(my.output)
# summary(my.output)
# saveRDS(my.output, file = "~/Developer/Serengeti_Rabies/temp/Round2_NoVC_1000_SummaryR0.rda")
#  
# # > summary(my.output)
# # trans.ave       trans.geo          dd.ave          dd.geo           be.ave           be.geo      
# # Min.   :1.044   Min.   :0.4092   Min.   :2.225   Min.   :0.8209   Min.   :0.2952   Min.   :0.1519  
# # 1st Qu.:1.082   1st Qu.:0.4182   1st Qu.:2.326   1st Qu.:0.8630   1st Qu.:0.3920   1st Qu.:0.1814  
# # Median :1.095   Median :0.4231   Median :2.373   Median :0.8728   Median :0.4337   Median :0.1938  
# # Mean   :1.098   Mean   :0.4245   Mean   :2.374   Mean   :0.8732   Mean   :0.4263   Mean   :0.1918  
# # 3rd Qu.:1.109   3rd Qu.:0.4305   3rd Qu.:2.410   3rd Qu.:0.8844   3rd Qu.:0.4607   3rd Qu.:0.2025  
# # Max.   :1.208   Max.   :0.4478   Max.   :2.554   Max.   :0.9144   Max.   :0.5300   Max.   :0.2256  
# 
# 
# # This uses the runs with VC from Round2 but filters out so we only retain those that correspond
# #      to the runs used in the R0 calculations
# # Compute Re and distinct dogs properly by reading in the full runs
# 
# # Load up the file produced by the post-processing step in Java
# sim_round <- "Round2_1000"
# paramMinMax.str <- "001_7100" # Number of runs
# sim_Round2 <- read.csv(paste0(ff, sim_round, "/output_files/epi_outcomes_", paramMinMax.str, ".csv"))
# dim(sim_Round2)
# # Load up abc file produced by R
# abc <- read.csv(paste0(ff, sim_round, "/postprocessing/abc_", paramMinMax.str, ".csv")) # This is the file produced by the post-processing step in Java
# dim(abc)
# 
# my.output.vc <- data.frame(trans.ave = c(), trans.geo = c(), 
#                         dd.ave = c(), dd.geo = c(),
#                         be.ave = c(), be.geo = c()) # Note that we don't currently output distinct S, E, in full run output
# for (rr in 1:nrow(abc)) {
#   if (round(abc$TdMean[rr], digits = 5) == 0.26297) {
#     print(rr)
#     # Compute statistics
#     sim_1 <- read.csv(paste0(ff, sim_round, "/output_files/",sim_round, "_sim_cases_",sprintf("%.3d", c(rr)),".csv" ))
#     mean_transmissions <- mean(sim_1$nTransmissions)
#     mean_DD <- mean(sim_1$nDistinctDogs)
#     geo_transmissions <- geoMean(sim_1$nTransmissions + 1) - 1
#     geo_dd <- geoMean(sim_1$nDistinctDogs + 1) - 1
#     mean_be <- mean(sim_1$nBitesE)
#     geo_be <- geoMean(sim_1$nBitesE + 1) - 1
#     my.output.vc <- rbind(my.output.vc, data.frame(trans.ave = mean_transmissions, trans.geo = geo_transmissions, 
#                                              dd.ave = mean_DD, dd.geo = geo_dd,
#                                              be.ave = mean_be, be.geo = geo_be))
#   }
# }
# summary(my.output.vc)
# dim(my.output.vc)
# saveRDS(my.output.vc, file = "~/Developer/Serengeti_Rabies/temp/Round2_OptVC_1000_SummaryR0.rda")
# 
# # > summary(my.output.vc)
# # trans.ave        trans.geo          dd.ave          dd.geo           be.ave            be.geo       
# # Min.   :0.7641   Min.   :0.3323   Min.   :1.884   Min.   :0.8055   Min.   :0.04615   Min.   :0.02947  
# # 1st Qu.:0.9391   1st Qu.:0.3911   1st Qu.:2.332   1st Qu.:0.9114   1st Qu.:0.14359   1st Qu.:0.07755  
# # Median :0.9882   Median :0.4060   Median :2.459   Median :0.9414   Median :0.17859   Median :0.09479  
# # Mean   :0.9820   Mean   :0.4046   Mean   :2.458   Mean   :0.9421   Mean   :0.18823   Mean   :0.09747  
# # 3rd Qu.:1.0374   3rd Qu.:0.4180   3rd Qu.:2.579   3rd Qu.:0.9704   3rd Qu.:0.22530   3rd Qu.:0.11750  
# # Max.   :1.1448   Max.   :0.4505   Max.   :2.876   Max.   :1.0688   Max.   :0.43611   Max.   :0.18231  
# 
# summary(my.output[c("trans.ave","dd.ave","be.ave")])
# summary(my.output.vc[c("trans.ave","dd.ave","be.ave")])
# 
# mean(my.output$dd.ave / my.output.vc$dd.ave) # 0.9704818 (i.e. dd higher with VC ... 3% lower without VC)
# mean(my.output$trans.ave / my.output.vc$trans.ave) # 1.124785 (i.e. Re 10-12% higher without VC)
# 
# abc[27,c("TdMean","ThShape","ThScale","ThMean","densityDependence")]
# 
# # Notes to Rebecca:
# # - Are distinctE and distinctV recorded in Case? It would be good to instrument these in the simulation output
# #      for each run to allow proper averages to be computed
# # - It looks as though in the runs with vaccination, Re < 1 (which is expected), but it is slightly above 1
# #      without vaccination. The number of distinct dogs bitten is slightly lower without vaccination, presumably
# #      because blow-up causes population depletion - this is very small difference (~2%)
# # - The number of bites lost to 



